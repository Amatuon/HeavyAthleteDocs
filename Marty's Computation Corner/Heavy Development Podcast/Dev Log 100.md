Wow everyone 100 episodes of the podcast. I can't believe we made it to this impressive milestone. If you're reading this I hope you know that there are only 10 kinds of people in the world. Those who understand binary and those who don't.

Hi there this is Michael from HeavyAthlete.com today's episode is going to be about complexity. Not time or memory complexity I won't be going over big O notation or anything. Rather I'll be talking about real complexity and why it is actually un avoidable in software. 

If you are a programmer at one point in your life you probably fell pretty close philosophically to the mathematician David Hilbert. You have probably heard this name before. The Hilbert curve which was the first known space filling curve was named after him as he discovered it. I'm not going to be talking about space filling curves today either. Instead I'm going to start by talking about a small part of Hilbert's philosophy. In Hilbert's time their was an idea that we might be able to complete mathematics. That we could write down the ultimate equation, prove the last proof, and be done with it. Hilbert helped lead the charge in trying to finish off mathematics once and for all. His epitaph reads "We must know. We will know". I think that is the best way to quickly sum up many programmers, scientists, and mathematicians during their college years. "We must know. We will know" those are powerful intoxicating words. There is such a promise in there. Unfortunately Hilbert was wrong. And not just wrong philosophically, but wrong mathematically. If Hilbert were correct then computer science would have been so much easier. As we design the systems and interactions we should have the control to make totally internally logically consistent systems. Systems where we do know. If Hilbert was correct we should be able to design flawless, un exploitable, perfect code. Experience tells us a different story. Does us falling short of this ideal boil down to a skill issue? Admittedly most bugs are in fact symptoms of skill issues. But that isn't the only problem. I said Hilbert was wrong mathematically. Its time to talk about Kurt Gödel.

Gödel was an Austrian-American mathematician. While he has a very interesting story of concern today is his incompleteness theorem. I'm going to paraphrase a bit but the Gödel incompleteness theorem tells us that any sufficiently advanced logical system will inherently be incomplete. Effectively we can't write down all the rules which hold about a system. If you want proof go read his it is very interesting. So what does this mean for us? Does this even apply to computers in the first place? If you use a turning complete language you are subject to this. If your program is more complex than Hello World than its already too late. 

What you have to understand is that complexity doesn't sneak in to projects. Its not a malevolent force trying to enter our little self contained worlds of perfect order. Its baked in. Let me give you a tangible example. On Heavy Athlete obviously we keep track of a lot of scores. And unless you are crazy or have no idea how computers work the scores work basically how you would expect them too. Scores have meta data linking them to the athlete that threw them, the game they threw them at, as well as other things like what class and flight they belong to, and what date they occurred on. Then you have the actual score. In highland games we have 9 events and all of them get recorded in the same score. This is all super easy while having a database for these is cool, even a non programmer could do all this in a large excel spreadsheet. So where's the complexity. Well that's true for scores but at time of writing there are three different types of scores in production, a fourth type in development, and a fifth type being designed to address future / current problems. If you think that's ridiculous and crazy let me explain the complexity that my explorations in this space brought to light. First let me address the elephant in the room. Yes everything I'm going to explain could have been handled with one type of score. It just would have had to mutate to keep up with added complexity. For a athletics score keeping website though having something as fundamental as how scores are represented be mutable is terrifying. Anyway lets talk about the complication which caused the first schism in scores. Heavy Athlete has to play nice with other scoring websites. In fact we had an entire database full of scores before a single score was entered using our site. To date most scores on the site actually originate elsewhere. So where's the complexity? I am the source of truth for all scores which originate in my system. But I am not the source of truth for scores that don't originate in my system. So if a score is updated on a different website should my site copy that change? Well it depends, who is the source of truth for that score? In the end it was easier to have two types of scores: Scores, which are Heavy Athlete all the way down, and Historic Scores, which come from elsewhere. The final straw was actually something unexpected for most people. Since Heavy Athlete handles payment one of the fields in the scores meta data encoded the payment status. For Historic Scores this is unknowable and un needed information. So to help separate concerns two types of scores were born. At the first test game for Heavy Athlete a new complication came up. A thrower showed up on a whim. They hadn't signed up ahead of time and the athletic director let them throw anyway. So why is this a problem? Well it couldn't be entered as a score, because scores are linked to athletes and athletes need to sign up on Heavy Athlete for a free account. Since this athlete hadn't already done that a non nullable field couldn't be set. Also it was inherently wrong to create a historic score for them. Historic scores have other sites as their source of truth. This score needed to be attached to a historic athlete while also having Heavy Athlete be its source of truth.  Thus a third type of score was born the claimable score. As a side note when athletes sign up on Heavy Athlete they can claim historic athletes and all scores associated with them this way typos, name changes, and age based class info can all be reconciled in the Heavy Athlete rankings. We actually made it almost a year with these three types of scores. There was kinda another type but it wasn't real. Internally I refer to these scores as transient scores. They are scores that exist for a computation purpose but don't actually get written to the database. They are very useful for comparing two scores or constructing an athletes sum of best scores. Eventually a new feature was added to the site which was the all time rankings. With this you can see how you stack up against the legends and we can answer definitively who is the GOAT in our sport. Now this feature was a rush job, which is a story for another time, but the demand was too great and I released it anyway. There are over 20,000 athletes, over 125,000 scores and over 900,000 throws in the database. While most of the time we get to work with a reasonable sub set of that data the GOAT hits different. This was too much computation for our poor transient scores. Everything slowed down way too much as we spent a lot of resources calculating these scores. So it was time to make them official. Instead of transients these are now called meta scores. The transients still exist in a few places but most of the heavy lifting has been handed off to the meta scores. So what makes these so special? Well finally this is something that if you can do it a spreadsheet you are a smarter man than me. Meta scores have the ability to calculate themselves. Want to know the sum of best throws for an athlete in a particular class and year? Just grab the meta score. Oh that score doesn't exist? When you fetch it, it springs into existence and figures out what its values should be. They also have the power to stay current. When a score, historic score, claimable score, or meta score that isn't all time best is updated it will ask for the appropriate meta score and update it if its own value is larger. This way we shift the calculation to new data entry instead of when a user requests it. Wow that's a lot of work! Why are we doing this again? Its all so that the GOAT feature runs almost instantly instead of taking multiple minutes per request. Finally lets talk about the proposed new score type the shadow score. Score may actually be to strong of a classification for these. Instead a better name will probably be shadow marks. Please don't sue me Bethesda this has nothing to do with the thieves guild. In order to provide live scoring capabilities one of the features for minimum viable product is placement calculation. I mean if I have all the data I should be able to tell you who's in first. The complication is that in an actual game their are multiple throws per athlete per event but only the best gets entered as their score. I could update everything except meta scores to hold an array of marks for each event and then always select the best from that list. But that slows down the access of scores everywhere on a site whose primary job may I remind you is to process scores. Instead I think that shadow marks offer a better solution they will be able to be attached to scores selectively so that the live scoring feature can do its job in peace without impacting everything else. 

Okay so my script tells me I spent 1,200 words explaining scores to you. Why did I bother? Did you notice in all of that discussion never once did I talk about skill issue based bugs? Don't get me wrong there were tons of them, but I don't think that the inherent design of my database is flawed. Instead its incomplete. My design solved the problems that existed in front of me at the time and the site worked. But as new features were added or users encountered perfectly reasonable use cases that I hadn't covered yet the complexity seems to have gone up. I would argue that the complexity didn't rise at each step. All the complexity was already there. Me creating Heavy Athlete didn't create the other sites I needed to integrate with they already existed. Creating GOAT rankings didn't create the demand for them, people wanted to know and therefore I created the feature. Live scores are the same. I don't have to explain the concept of live scoring to you, its something that predates my implementation. While I'm sure that its possible to add complexity for the complexity's sake, I think that most of the complexity that makes its way into software isn't our fault. I think that systems are inherently complex and to capture them and express them meaningfully requires us to wrestle with that complexity and express it in our code. 

So while many "software experts" will tell you to limit or avoid complexity, I mean one of my favorites to read literally calls it a demon, read the grug brained developer for more on that, I would say that it is unavoidable. Your project either dies with an epitaph reading "We must know. We will know." or it lives long enough to find the complicated parts. Don't be afraid of complexity. It's an indicator that you are solving a problem worth solving. If we want to reverse the enshitifcation of software we have to tackle more complex tasks. That being said don't make things complex for complexities sake. I swear to you that your project is mathematically incomplete and that infinite complexity is lurking there already. You don't need to create more just tackle what's already there.

This has been Michael McDougal from Heavy Athlete. I'll see you next time after I break some more things.